# 모노레포란?

모노레포(Monorepo)는 여러 개의 프로젝트나 패키지를 **하나의 단일 리포지토리에서 관리하는 방식**을 의미합니다. 전통적으로 많은 개발 팀은 각 프로젝트를 별도의 리포지토리에서 관리하는 멀티레포(Multi-Repo) 방식을 사용해 왔습니다. 하지만 프로젝트의 규모가 커지고, 여러 팀이 협업해야 하는 상황이 늘어나면서 코드의 일관성 유지, 의존성 관리, 협업 효율성 등의 문제가 발생하게 되었습니다.

예를 들어, 여러 애플리케이션이 공통으로 사용하는 라이브러리나 유틸리티 함수가 있을 때, 멀티레포에서는 각 리포지토리에서 해당 코드를 복사하거나 별도의 패키지로 관리해야 합니다. 이는 코드 중복이나 버전 관리의 어려움으로 이어질 수 있습니다.

모노레포는 이러한 문제를 해결하기 위해 등장했습니다. 모든 프로젝트를 하나의 리포지토리에서 관리함으로써 **코드 재사용성**, **의존성 관리의 일관성**, **협업의 효율성**을 높일 수 있습니다. 특히 대규모 팀이나 기업에서는 모노레포를 통해 여러 팀 간의 협업을 원활하게 하고, 코드 품질을 유지하며, 개발 속도를 향상시킬 수 있습니다.

## 모노레포의 배경

모노레포의 개념은 구글(Google), 페이스북(Facebook), 마이크로소프트(Microsoft) 등과 같은 대규모 기술 기업에서 시작되었습니다. 이들 기업은 수백, 수천 개의 프로젝트와 방대한 양의 코드를 관리해야 했습니다. 멀티레포 방식으로는 코드 중복, 의존성 충돌, 협업의 어려움 등이 발생하여 효율적인 개발이 어려웠습니다.

구글은 모든 코드를 단일 리포지토리에서 관리하는 모노레포 방식을 도입하여 개발자들이 동일한 코드베이스에서 작업하고, 코드 재사용과 협업을 용이하게 하였습니다. 이를 통해 생산성과 코드 품질을 크게 향상시킬 수 있었습니다.

## 모노레포와 멀티레포의 비교

모노레포와 멀티레포는 코드 관리 방식에서 큰 차이가 있습니다. 아래 표는 두 방식의 특징을 비교한 것입니다.

| **특징**         | **모노레포**                                                         | **멀티레포**                                   |
|----------------|--------------------------------------------------------------------|--------------------------------------------|
| **코드베이스 관리** | 단일 리포지토리에서 모든 프로젝트 관리                                     | 프로젝트별로 별도의 리포지토리 관리                |
| **의존성 관리**   | 공통 의존성 공유 및 통합 관리                                           | 프로젝트별로 의존성 개별 관리                   |
| **협업**        | 팀 간의 협업과 코드 공유 용이                                          | 프로젝트 간 협업이 복잡할 수 있음                |
| **빌드 및 배포**  | 빌드 시스템과 CI/CD 파이프라인 통합 가능하지만 초기 설정 복잡                    | 각 프로젝트별로 빌드 및 배포 관리                 |
| **접근 권한 관리** | 프로젝트별 접근 권한 세분화 어려움                                      | 프로젝트별로 접근 권한 관리 용이                 |

### 모노레포 파일 구조 예시

모노레포에서는 모든 프로젝트와 패키지가 하나의 리포지토리 내에서 관리되며, 공통된 루트 디렉토리 아래에 위치합니다. 이를 통해 프로젝트 간의 의존성 공유가 용이하며, 빌드, 테스트, 배포 등의 워크플로우를 통합할 수 있습니다.

```
/monorepo
  /packages
    /app1
      /src
      /package.json
    /app2
      /src
      /package.json
    /shared-library
      /src
      /package.json
  /node_modules
  /package.json
```

위 구조에서 `packages` 디렉토리에는 여러 애플리케이션(`app1`, `app2`)과 공통으로 사용하는 라이브러리(`shared-library`)가 포함되어 있습니다. 모든 패키지가 루트 `package.json` 파일에서 관리되며, 의존성도 `node_modules`를 통해 공유됩니다.

### 멀티레포 파일 구조 예시

멀티레포에서는 각 프로젝트가 별도의 리포지토리에서 관리됩니다. 프로젝트마다 독립적으로 빌드, 배포되며, 각 프로젝트는 자체 의존성을 관리합니다.

```
/app1-repo
  /src
  /package.json
  /node_modules

/app2-repo
  /src
  /package.json
  /node_modules

/shared-library-repo
  /src
  /package.json
  /node_modules
```

각 애플리케이션(`app1-repo`, `app2-repo`)과 공유 라이브러리(`shared-library-repo`)가 별도의 리포지토리에서 관리되며, 의존성도 개별적으로 설치됩니다.

## 모노레포의 장단점

모노레포는 여러 프로젝트를 하나의 리포지토리에서 관리함으로써 많은 이점을 제공합니다. 하지만 그만큼 도전 과제도 존재합니다. 아래에서 모노레포의 주요 장단점을 자세히 살펴보겠습니다.

### 장점

#### 1. 코드 재사용과 공유의 용이성

모노레포의 가장 큰 장점 중 하나는 **코드 재사용과 공유가 매우 용이**하다는 점입니다. 여러 프로젝트가 하나의 리포지토리에서 관리되므로, 공통 모듈이나 라이브러리를 손쉽게 공유할 수 있습니다.

예를 들어, 여러 애플리케이션에서 동일한 UI 컴포넌트 라이브러리를 사용한다고 가정해 봅시다. 모노레포에서는 해당 라이브러리를 `shared-library` 패키지로 만들어 `packages` 디렉토리에 포함시킬 수 있습니다. 이렇게 하면 라이브러리의 변경 사항이 모든 애플리케이션에 즉시 반영됩니다. 개발자들은 중복된 코드를 관리할 필요 없이, 공통 라이브러리를 한 곳에서 관리하고 유지보수할 수 있습니다.

또한, 코드베이스가 하나로 통합되어 있기 때문에 **공통된 코딩 스타일과 규칙**을 적용하기도 용이합니다. ESLint, Prettier와 같은 도구를 루트 설정으로 관리하여 모든 프로젝트에 일관된 코드 스타일을 적용할 수 있습니다.

#### 2. 의존성 관리의 일관성

모노레포에서는 **의존성 관리가 일관성 있게 이루어집니다**. 모든 프로젝트가 동일한 의존성 버전을 사용하므로, 프로젝트 간의 **의존성 충돌 문제를 최소화**할 수 있습니다.

예를 들어, 여러 프로젝트가 `React`를 사용한다면, 모노레포에서는 `React`의 버전을 루트 `package.json`에서 한 번만 지정하여 모든 프로젝트에서 동일한 버전을 사용하게 할 수 있습니다. 이를 통해 각 프로젝트가 서로 다른 `React` 버전을 사용하여 발생할 수 있는 호환성 문제를 예방할 수 있습니다.

또한, 공통 의존성들은 루트의 `node_modules`에 설치되기 때문에 **중복 설치를 방지**하고, **디스크 공간과 설치 시간**을 절약할 수 있습니다. 이는 특히 대규모 프로젝트에서 설치 시간이 길어지는 문제를 해결하는 데 도움이 됩니다.

#### 3. 협업의 효율성

모노레포는 **협업 측면에서 큰 장점**을 제공합니다. 여러 팀이 동일한 코드베이스에서 작업하므로, 팀 간의 변경 사항을 **즉시 공유**할 수 있고, **코드 리뷰**나 **피드백**을 빠르게 주고받을 수 있습니다.

예를 들어, 팀 A가 공통 유틸리티 함수를 개선하면, 그 변경 사항은 즉시 팀 B의 프로젝트에서도 사용할 수 있습니다. 이를 통해 팀 간의 **중복 작업을 줄이고**, **의사소통을 원활하게** 할 수 있습니다.

또한, 모노레포에서는 모든 코드가 하나의 리포지토리에 있기 때문에 **이슈 추적**이나 **프로젝트 관리**도 통합적으로 수행할 수 있습니다. 이는 프로젝트 관리의 복잡성을 줄이고, 전체적인 개발 프로세스를 개선합니다.

#### 4. 대규모 리팩토링의 용이성

모노레포에서는 **대규모 리팩토링을 쉽게 수행**할 수 있습니다. 모든 프로젝트가 하나의 코드베이스에 있기 때문에, 공통 모듈이나 API의 변경 사항을 한 번에 모든 프로젝트에 적용할 수 있습니다.

예를 들어, 공통 API의 스펙이 변경되었을 때, 모노레포에서는 해당 API를 사용하는 모든 프로젝트에서 동시에 수정할 수 있습니다. 이는 멀티레포 방식에서 각 프로젝트를 개별적으로 수정해야 하는 번거로움을 없애주고, **일관된 코드 품질**을 유지하는 데 도움이 됩니다.

또한, **기술 부채를 관리**하고, **코드의 일관성**을 유지하며, **버그를 빠르게 수정**할 수 있습니다.

### 단점

#### 1. 빌드 시간의 증가

모노레포의 가장 큰 단점 중 하나는 **빌드 시간이 길어질 수 있다는 점**입니다. 프로젝트 규모가 커지고 패키지 수가 많아질수록 전체 빌드 시간을 관리하는 것이 어려워질 수 있습니다.

예를 들어, `app1`에 작은 변경 사항이 있더라도, 의존성 관계로 인해 전체 프로젝트를 빌드해야 하는 상황이 발생할 수 있습니다. 이는 개발자들의 생산성을 저하시킬 수 있습니다.

이를 해결하기 위해서는 **의존성 그래프 분석**을 통해 변경된 패키지와 그에 영향을 받는 패키지만 빌드하는 **스마트 빌드 시스템**이나 **빌드 캐싱**과 같은 기능이 필요합니다. **Nx**, **Turborepo**와 같은 도구는 이러한 기능을 제공하여 불필요한 빌드를 방지하고 빌드 시간을 단축하는 데 도움을 줍니다.

#### 2. 의존성 관리의 복잡성

모노레포에서는 **의존성 관리가 복잡해질 수 있습니다**. 여러 패키지가 서로 다른 버전의 의존성을 필요로 하거나, 특정 패키지에서 사용하는 라이브러리의 버전이 다른 패키지와 충돌하는 경우 문제가 발생할 수 있습니다.

예를 들어, `app1`은 `React 16`을 사용하고, `app2`는 `React 17`을 사용하고자 할 때, 공통 `node_modules`를 사용하는 모노레포 구조에서는 **버전 충돌**이 발생할 수 있습니다.

이를 해결하기 위해서는 각 패키지별로 **독립된 의존성 관리**를 설정하거나, **의존성 버전 전략을 신중하게 계획**해야 합니다. **Yarn Berry**의 **Plug'n'Play(PnP)** 기능이나 **npm workspaces**를 활용하여 패키지별 의존성을 관리할 수 있습니다.

#### 3. 초기 설정의 복잡성

모노레포는 **초기 설정이 복잡**할 수 있습니다. 여러 프로젝트를 하나의 리포지토리에서 관리하기 위해서는 **빌드 도구**, **테스트 환경**, **CI/CD 파이프라인** 등을 통합적으로 설정해야 합니다.

예를 들어, 각 프로젝트마다 다른 빌드 설정이나 테스트 프레임워크를 사용한다면, 이를 모노레포에서 통합 관리하기 위해서는 **세심한 설정 작업**이 필요합니다. 또한, 팀원들이 새로운 툴과 워크플로우에 **익숙해지는 데 시간**이 걸릴 수 있습니다.

이러한 문제를 해결하기 위해서는 **Nx**, **Lerna**, **Turborepo**와 같은 모노레포 툴을 활용하여 설정 과정을 간소화하고, **문서화**와 **교육**을 통해 팀원들의 이해를 도울 수 있습니다.

#### 4. 접근 권한 관리의 어려움

모노레포에서는 **접근 권한을 세분화**하는 것이 어렵습니다. 모든 코드가 하나의 리포지토리에 있기 때문에, 특정 프로젝트나 디렉토리에 대한 접근 권한을 별도로 설정하기가 복잡합니다.

예를 들어, 팀 A는 `app1`만 수정할 수 있고, 팀 B는 `app2`만 수정할 수 있도록 하고 싶을 때, 모노레포에서는 이를 구현하기가 어렵습니다. Git에서는 리포지토리 단위로 접근 권한을 관리하기 때문입니다.

이를 해결하기 위해서는 **Git Submodules**나 **Git Sparse Checkout**을 활용하거나, **서드파티 도구**를 사용하여 디렉토리별 접근 권한을 관리할 수 있습니다. 하지만 이는 추가적인 복잡성을 야기할 수 있습니다.

---

이렇게 모노레포의 장단점을 살펴보았습니다. 모노레포는 코드 재사용성과 협업 효율성을 높일 수 있지만, 빌드 시간 증가나 의존성 관리의 복잡성 등도 고려해야 합니다. 다음으로, 모노레포를 효율적으로 관리하기 위한 툴의 주요 기능과 대표적인 모노레포 툴에 대해 알아보겠습니다.

# 모노레포 툴의 주요 기능

모노레포를 효율적으로 운영하기 위해서는 **적절한 툴**을 사용하는 것이 중요합니다. 모노레포 툴은 여러 프로젝트와 패키지를 하나의 리포지토리에서 관리하면서 발생하는 복잡한 문제를 해결하고, 개발 프로세스를 개선하는 다양한 기능을 제공합니다.

주요 기능들은 다음과 같습니다:

1. **패키지 관리**
2. **버전 관리**
3. **빌드 시스템**
4. **CI/CD 통합**

각 기능을 자세히 살펴보겠습니다.

## 1. 패키지 관리

### 1.1 의존성 중복 제거

모노레포에서는 여러 패키지가 동일한 의존성을 사용하는 경우가 많습니다. 이를 효율적으로 관리하기 위해 모노레포 툴은 **의존성 중복 제거** 기능을 제공합니다.

예를 들어, `Yarn Workspaces`나 `npm workspaces`를 사용하면 루트 `package.json` 파일에서 `workspaces` 필드를 통해 하위 패키지를 정의하고, 공통 의존성을 루트 `node_modules`에서 관리할 수 있습니다.

```json
// 루트 package.json
{
  "private": true,
  "workspaces": ["packages/*"]
}
```

이렇게 설정하면 모든 패키지가 공통의 `node_modules`를 사용하여 의존성을 공유하게 됩니다. 이를 통해 **디스크 공간을 절약**하고, **의존성 설치 시간을 단축**할 수 있습니다.

### 1.2 로컬 의존성 관리

모노레포 내의 패키지들은 서로를 **로컬 의존성**으로 참조할 수 있습니다. 이는 패키지 간의 변경 사항을 즉시 반영하고, 외부에 패키지를 배포하지 않아도 되는 장점이 있습니다.

예를 들어, `app1`에서 `shared-library`를 의존성으로 사용할 때, 아래와 같이 `package.json`에 설정할 수 있습니다.

```json
// app1 package.json
{
  "dependencies": {
    "shared-library": "1.0.0"
  }
}
```

모노레포 툴은 `shared-library`를 로컬에서 찾아서 의존성으로 연결해 줍니다.

## 2. 버전 관리

모노레포에서는 여러 패키지의 버전을 어떻게 관리할지가 중요한 이슈입니다. 주요 버전 관리 전략은 **단일 버전 전략**과 **독립 버전 전략**입니다.

### 2.1 단일 버전 전략

**단일 버전 전략**은 모든 패키지가 동일한 버전을 공유하는 방식입니다. 이는 버전 관리가 단순하고, 패키지 간의 호환성을 보장할 수 있다는 장점이 있습니다.

예를 들어, `app1`과 `app2`가 모두 버전 `1.0.0`을 사용하고, `shared-library`를 `1.0.0`으로 참조합니다. 패키지 중 하나를 수정하여 버전을 올리면, 모든 패키지가 함께 버전이 올라갑니다.

그러나 변경이 없는 패키지도 버전이 올라가기 때문에, **불필요한 버전업**이 발생할 수 있고, **버전 번호의 의미가 희석**될 수 있습니다.

### 2.2 독립 버전 전략

**독립 버전 전략**은 각 패키지가 독립적으로 버전이 관리되는 방식입니다. 이는 패키지별로 필요한 경우에만 버전을 업데이트할 수 있어 효율적입니다.

예를 들어, `app1`은 버전 `1.0.0`, `app2`는 버전 `1.1.0`, `shared-library`는 버전 `2.0.0`일 수 있습니다. 각 패키지는 변경 사항에 따라 독립적으로 버전을 관리합니다.

그러나 패키지 간의 의존성 버전을 수동으로 관리해야 할 수 있어 **호환성 관리가 복잡**해질 수 있고, 여러 개의 버전을 관리해야 하므로 **버전 관리의 복잡성**이 증가할 수 있습니다.

## 3. 빌드 시스템

모노레포에서는 여러 패키지를 효율적으로 빌드하기 위한 **빌드 시스템**이 중요합니다. 주요 기능은 다음과 같습니다.

### 3.1 변경 사항 기반 빌드

모노레포 툴은 **의존성 그래프**를 활용하여 **변경된 패키지와 그에 영향을 받는 패키지만 빌드**할 수 있습니다. 이를 통해 불필요한 빌드를 방지하고 빌드 시간을 단축할 수 있습니다.

예를 들어, `app1`에만 변경 사항이 있다면, `app1`과 `app1`이 의존하는 패키지만 빌드하면 됩니다.

### 3.2 빌드 캐싱

빌드 결과를 캐싱하여 **동일한 입력에 대해 동일한 출력이 나오는 경우 빌드를 스킵**할 수 있습니다. 이는 빌드 시간을 크게 단축시킵니다.

**Nx**, **Turborepo**는 이러한 빌드 캐싱 기능을 제공합니다.

### 3.3 병렬 빌드 및 분산 빌드

여러 패키지를 **병렬로 빌드**하여 멀티코어 CPU의 성능을 최대한 활용할 수 있습니다. 또한, **분산 빌드 시스템**을 도입하여 빌드 작업을 여러 머신에 분산시킬 수 있습니다.

## 4. CI/CD 통합

모노레포 툴은 **CI/CD 파이프라인과의 통합**을 통해 효율적인 개발 프로세스를 구축할 수 있습니다.

### 4.1 변경된 패키지만 테스트 및 배포

변경된 패키지만을 대상으로 **테스트**하고 **배포**할 수 있습니다. 이는 CI/CD 파이프라인의 시간을 단축하고, 리소스를 절약할 수 있습니다.

### 4.2 파이프라인의 병렬 처리

빌드, 테스트, 배포 과정을 **병렬로 처리**하여 전체 파이프라인의 효율성을 높일 수 있습니다.

### 4.3 자동 릴리즈 및 배포

버전 관리와 연계하여 **자동으로 릴리즈 노트**를 생성하고, **패키지를 배포**할 수 있습니다. 이는 릴리즈 과정에서 발생할 수 있는 실수를 최소화하고, 일관성을 유지할 수 있게 해줍니다.

---

이러한 기능들을 제공하는 모노레포 툴을 사용하면, 모노레포를 효율적으로 관리하고 개발 생산성을 높일 수 있습니다. 다음으로, 대표적인 모노레포 툴들을 비교해 보겠습니다.

# 주요 모노레포 툴 비교

모노레포를 관리하기 위한 툴은 다양하며, 각 툴은 고유한 기능과 장점을 가지고 있습니다. 프로젝트의 특성과 규모에 따라 적절한 툴을 선택하는 것이 중요합니다. 여기서는 **Turborepo**, **Lerna**, **Nx**, **Yarn Workspaces**를 비교하겠습니다.

## Turborepo

**Turborepo**는 **Vercel**에서 개발한 최신 모노레포 관리 툴로, 대규모 프로젝트에서의 **성능 최적화**에 중점을 둡니다.

### 주요 특징

#### 1. 분산 빌드 캐싱

Turborepo는 **분산 빌드 캐싱** 기능을 제공하여 빌드 결과를 캐싱하고 재사용합니다. 이를 통해 빌드 시간을 크게 단축할 수 있습니다.

#### 2. 직관적인 설정과 사용성

설정 파일인 `turbo.json`을 통해 빌드 파이프라인을 정의하며, 설정이 간단하고 사용이 직관적입니다.

```json
// turbo.json 예시
{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    }
  }
}
```

#### 3. 유연한 구성과 다중 언어 지원

JavaScript, TypeScript뿐만 아니라 다양한 언어와 프레임워크를 지원하여 유연하게 구성할 수 있습니다.

### 장점

- **높은 빌드 성능**: 분산 빌드 캐싱으로 빌드 시간을 단축합니다.
- **개발자 경험 향상**: 설정이 간단하고 사용이 쉽습니다.
- **유연성**: 다양한 언어와 프레임워크를 지원합니다.

### 단점

- **초기 설정의 복잡성**: 고급 기능을 사용하려면 설정이 복잡해질 수 있습니다.
- **커뮤니티와 문서의 제한**: 비교적 새로운 툴로, 자료가 부족할 수 있습니다.

### Turborepo를 선택해야 하는 경우

- **대규모 프로젝트**에서 빌드 성능이 중요한 경우.
- 최신 기술을 도입하여 **성능 최적화**를 원하는 경우.
- 다양한 언어와 프레임워크를 사용하는 **복합적인 프로젝트**를 관리해야 하는 경우.

## Lerna

**Lerna**는 가장 널리 사용되는 모노레포 관리 툴 중 하나로, NPM 패키지의 **버전 관리**와 **배포**에 특화되어 있습니다.

### 주요 특징

#### 1. 패키지 관리와 버전 관리

Lerna는 **단일 버전 전략**과 **독립 버전 전략**을 모두 지원하여 프로젝트에 맞게 선택할 수 있습니다.

#### 2. 의존성 관리

패키지 간 의존성을 자동으로 관리하고, 중복된 의존성을 최적화합니다.

#### 3. 배포 자동화

변경된 패키지만 배포할 수 있는 기능을 제공합니다.

### 장점

- **사용의 간편함**: 설정이 직관적이고 사용이 쉽습니다.
- **유연한 버전 관리**: 버전 관리 전략을 선택할 수 있습니다.
- **플러그인 생태계**: 다양한 플러그인을 통해 기능을 확장할 수 있습니다.

### 단점

- **성능 제한**: 대규모 프로젝트에서는 빌드 및 설치 시간이 길어질 수 있습니다.
- **제한된 빌드 기능**: 빌드 최적화 기능이 부족합니다.

### Lerna를 선택해야 하는 경우

- **작은 규모의 프로젝트**를 운영하는 경우.
- **간단한 패키지 관리와 배포**가 필요한 경우.
- 빌드 최적화보다는 **버전 관리**에 초점을 두는 경우.

## Nx

**Nx**는 **구글**의 전직 엔지니어들이 만든 모노레포 관리 툴로, 대규모 엔터프라이즈급 애플리케이션을 위한 기능을 제공합니다.

### 주요 특징

#### 1. 스마트 빌드 캐싱

Nx는 **스마트 빌드 캐싱**을 통해 변경되지 않은 부분은 빌드를 스킵하고, 빌드 결과를 캐싱하여 빌드 시간을 단축합니다.

#### 2. 의존성 그래프 시각화

패키지 간의 **의존성 그래프**를 시각화하여 관리할 수 있습니다.

```bash
# 의존성 그래프 시각화 명령어
nx graph
```

#### 3. 확장성과 플러그인 시스템

React, Angular, Node.js 등 다양한 프레임워크와 언어를 지원하며, 플러그인을 통해 기능을 확장할 수 있습니다.

### 장점

- **강력한 빌드 최적화**: 스마트 캐싱과 변경 사항 기반 빌드.
- **의존성 관리의 용이성**: 의존성 그래프 시각화.
- **확장성**: 다양한 플러그인과 엔터프라이즈급 기능 제공.

### 단점

- **러닝 커브**: 기능이 많아 초기 학습이 필요합니다.
- **복잡한 설정**: 세부적인 설정이 복잡할 수 있습니다.

### Nx를 선택해야 하는 경우

- **대규모 프로젝트**를 운영하며 빌드 최적화와 의존성 관리가 중요한 경우.
- 다양한 프레임워크와 언어를 사용하는 **복잡한 모노레포**를 관리해야 하는 경우.
- **엔터프라이즈급 기능**과 확장성이 필요한 경우.

## Yarn Workspaces

**Yarn Workspaces**는 **Yarn 패키지 매니저**의 기능으로, 모노레포에서 **의존성 관리**를 간단하게 할 수 있도록 도와줍니다.

### 주요 특징

#### 1. 간단한 설정

루트 `package.json` 파일에서 `workspaces` 필드를 추가하여 설정할 수 있습니다.

```json
// 루트 package.json
{
  "private": true,
  "workspaces": ["packages/*"]
}
```

#### 2. 의존성 중복 제거

워크스페이스 내의 패키지들은 공통 `node_modules`를 사용하여 의존성 중복을 제거합니다.

#### 3. NPM과의 호환성

NPM에서도 유사한 `workspaces` 기능을 제공합니다.

### 장점

- **설정의 간편함**: 빠르게 모노레포 환경을 구축할 수 있습니다.
- **의존성 관리 효율화**: 공통 의존성 공유.
- **패키지 매니저 통합**: 별도의 툴 없이 Yarn으로 관리 가능.

### 단점

- **제한된 기능**: 빌드나 테스트 자동화 기능이 부족합니다.
- **확장성의 한계**: 복잡한 요구사항을 충족하기 어려울 수 있습니다.

### Yarn Workspaces를 선택해야 하는 경우

- **작은 규모의 프로젝트**를 빠르게 시작하고 싶은 경우.
- 빌드나 배포 자동화가 필요하지 않고, **의존성 관리**만 필요한 경우.
- 별도의 모노레포 툴 도입 없이 **간단한 설정**으로 모노레포를 구축하고 싶은 경우.

---

각 툴의 특징과 장단점을 이해하고, 프로젝트의 요구사항에 맞게 적절한 툴을 선택하는 것이 중요합니다.

# 결론

모노레포는 여러 프로젝트를 하나의 리포지토리에서 관리하여 **코드 재사용성**, **협업 효율성**, **의존성 관리의 일관성** 등 많은 이점을 제공합니다. 하지만 **빌드 시간 증가**, **의존성 관리의 복잡성**, **초기 설정의 어려움** 등 도전 과제도 존재합니다.

이러한 장단점을 고려하여 모노레포를 도입할지 결정하고, 적절한 툴을 선택하여 효율적으로 운영하는 것이 중요합니다. 특히, **Nx**, **Turborepo**, **Lerna**, **Yarn Workspaces** 등 다양한 툴들이 있으므로 프로젝트의 규모와 특성에 맞게 선택해야 합니다.

마지막으로, 모노레포를 성공적으로 운영하기 위해서는 **팀원들의 이해와 협력**이 필수적입니다. 새로운 툴과 워크플로우에 대한 학습과 적응, 문서화, 커뮤니케이션을 통해 모노레포의 이점을 최대한 활용할 수 있습니다.

# 참고

- **Turborepo 공식 문서**: [https://turbo.build/repo/docs](https://turbo.build/repo/docs)
- **Nx 공식 문서**: [https://nx.dev](https://nx.dev)
- **Lerna 공식 문서**: [https://lerna.js.org](https://lerna.js.org)
- **Yarn Workspaces 공식 문서**: [https://classic.yarnpkg.com/en/docs/workspaces/](https://classic.yarnpkg.com/en/docs/workspaces/)
- **Google's Monolithic Repository**: [https://research.google/pubs/pub45424/](https://research.google/pubs/pub45424/)
- **모노레포 관리 베스트 프랙티스**: *실용적인 모노레포 관리 전략*, 홍길동 저, 2022
